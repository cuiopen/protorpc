<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<META NAME="generator" CONTENT="http://txt2tags.sf.net">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>﻿Techniques</TITLE>
<STYLE TYPE="text/css">
/* t2t --css-sugar support css
version:
	v0.9 090430;fixed IE bad toc link color
	v0.8 070613;zoomq clean base gary,and support anchor ed Title
	v0.7 2004;zoomq creat base deviantart.com
*/
body {
	background-color : #fdfdfd;
	font-family: Tahoma,SimSun,arial, helvetica, sans-serif; 
	font-size: 92%;
	/* line-height: 120%; */
	margin: 0px;
	padding: 0px;
	color:#494D4A;
}
SUP,SUB{
	font-size:11px;
}
a {
	color: #3B4A4A;
	text-decoration:underline; 
}
a:hover {color: #930;
	text-decoration: none; 
}
a:visited {color: #45544A;
	}
img {border: none;}
/*"
"font-family: courier, monospace;
*/

pre{
	border-left: 2px solid #AEBDCC;
	
	/*background-color: #323232;
	color:#9AEF3F;*/
	color:#5A695F;
	
	padding: 1em;
	font-family: "Courier New",Georgia,helvetica, sans-serif;  
	white-space: pre;
	/*" begin css 3 or browser specific rules - do not remove!
	see: http://forums.techguy.org/archive/index.php/t-249849.html */
	white-space: pre-wrap;
	word-wrap: break-word;
	white-space: -moz-pre-wrap;
	white-space: -pre-wrap;
	white-space: -o-pre-wrap;
	/* end css 3 or browser specific rules */
}
UL,OL{
	margin: 0em 0 0 .5em;
	padding: 0 .25em 0em 1em;
}
/*定义声明组*/
DL,DT{
	margin: .25em 0 0 .25em;
	padding: 0em 0em 0em .25em;
}
DT{
	font-weight:bold;
	font-size:105%;
}
DD{
	margin: .25em 0 0 .5em;
	padding: 0 .25em .25em 1em;
}
ul.plain {
	list-style-type: none;
	margin-left: 5px;
	padding-left: 5px;
}
H1,H2,H3,H4,H5,H6{
	font-family: Verdana, arial, helvetica, sans-serif; 
	text-align: left;
	color:#5A695F;
	margin-left : .5em;  
	padding : 4px;
	line-height: 1.2em;
}
H1 { 
	background-color :transparent;
	border-left : 5px solid #404E4E ;
	border-bottom : 1px dashed  #A9B3A9 ;
	font-size: 1.5em;
}
h2 { 
	border-left : 10px solid #526157 ;
	border-bottom : 1px dashed  #A9B3A9 ;
	font-size: 1.4em;
}
h3 {
	border-left : 15px solid #738278 ;
	border-bottom : 1px dashed  #A9B3A9 ;
	font-size: 1.3em;
}

h4 {
	border-left : 20px solid #88938D ;
	border-bottom : 1px dashed  #A9B3A9 ;
	font-size: 1.2em;
}
h5{
	border-left : 25px solid #B2B8B2 ;
	border-bottom : 1px dashed  #A9B3A9 ;
	font-size: 1.1em;
}
h6{
	border-left : 30px solid #C4C8C4 ;
	border-bottom : 1px dashed  #A9B3A9 ;
	font-size: 1em;
}

H1 A{text-decoration:none;}
H1 A:hover{text-decoration:overline;}

H2 A{text-decoration:none;}
H2 A:hover{text-decoration:overline;}

H3 A{text-decoration:none;}
H3 A:hover{text-decoration:overline;}

H4 A{text-decoration:none;}
H4 A:hover{text-decoration:overline;}

H5 A{text-decoration:none;}
H5 A:hover{text-decoration:overline;}

/*padding:5px 15px 10px 15px;  */
#banner {
	font-family: "Courier New",Georgia,Verdana, arial, helvetica, sans-serif;
	color:#CED8CE;
	background:#25342A;
	padding-left: 10px;
	letter-spacing: .2em;
	font-size:24px;
	font-weight:bold ;
	border-top:4px solid #738278;
	border-bottom: 0px solid  #4A584A;
}
#banner A{
	color:#E0FFB8;
	text-decoration:none;
}
#banner A:hover{
	color:#DAF4DA;
	text-decoration:overline ;
}
#banner SUP,SUB{
	font-size:12px;
	color:#DAE4DA;
}
#banner P#main{
	margin: 4px;
	padding: 4px;
}
#banner P#sub{
	font-size:12px;letter-spacing: 5px;
	margin: 4px;
	padding: 4px 4px 10px 4px;
}
#banner DIV#recent {
	border : 0px dotted #930;
	color:#DAE4DA;
	font-family: Georgia,arial, helvetica,sans-serif;
	position : absolute ;
	top: 2em;
	left: 39%;
	font-size:16px;
	letter-spacing: 2px;
}
/*text-transform:uppercase;*/
#content { 
	width: 69%;
	position: absolute;	
	background-color: transparence;
	border-right: 0px dotted #4A584A;
	margin: 0px;
	padding: 10px 5px 10px 10px;
}
/*<h2>Mon, 23 Jan 2006</h2>*/
h2.blosxomDate{
	font-family: Georgia,Verdana, arial, helvetica, sans-serif;
	text-align: right;
	border:0px solid #2B3A3A;
	margin: 0px 5px 5px 0px;
	padding: 0px 15px 0px 0px;
	border-bottom: 1px solid #2B3A3A;
}
H3#blosxomTitle {
	font-size: 90%;
	border-left:4px solid #88938D;
	border-bottom : 0px dashed  #A9B3A9 ;
	background-color: #546359;
	color:#A7AFA7;
	padding: 4px;
	margin: 5px 0px 0px 0px;
	font-weight:normal;
}

H3#blosxomTitle a { 
	color: #DDDDD0;
}

.blosxomStory{
	padding: 4px; 
	font-size: 92%;   
	border-left:2px solid #88938D;
	background-color: #ECEEEC;
}

.blosxomStory a { 
	color:#835959;
}

/*
"font-family: "Courier New",Georgia,helvetica, sans-serif; 
*/
.blosxomStoryLinks{
	font-size:90%;
	padding: 2px;
	margin: 0px;
	border:0px dotted #2B3A3A;
	background-color: #546359;
	color:#A7AFA7;
}
.blosxomStoryLinks a {
	color: #DDDDD0;
	text-decoration:none; 
}
.blosxomStoryLinks a:hover {
	color: #DDDDD0;
	text-decoration: underline; 
}
.blosxomStoryLinks a:visited {
	color: #BAC4BB;
}
/*"margin: 1px 0px 2px 0px  */
div.body {
	margin: 0px 10px 0px 10px;
}
div#header {
	font-family: Verdana, Arial, Helvetica, Sans-Serif;
	border-bottom: 0px dotted black;
	margin: 0px;
	padding: 0px;
	background-color :#454545;
}
/*文章大标*/
div#header H1{
	float: left;
	margin: 5px 5px 10px 15px;
	padding: 5px;
	font-size: 200%;
	font-weight : normal;
	color:#DAE4DA;
	border:0px;
}
/*文章副标*/
div#header H2 {
	text-align: right;
	margin: 0em;
	padding: .5em .5em 0em 0em;
	font-size: 130%;
	font-weight : normal;
	border:0px;
	color:#DAE4DA;
	border-right : 4px solid #A7AFA7;
}
/*文章说明*/
div#header H3{
	text-align: right;
	margin: 0em;
	padding: 0em .5em 0em 0em;
	font-size: 13px;
	font-weight : normal;
	border:0px;
	color:#D2D8D2;
	border-bottom : 2px solid #A7AFA7;
	border-right :  4px solid #A7AFA7;
}

div.toc {
	float: right;
	background-color :#454545;
	color:#BAC4BA;
	border-bottom : 4px solid #A7AFA7;
	border-left :   2px solid #A7AFA7;
	border-right :   4px solid #A7AFA7;
	padding: .5em 0em .5em .5em;
	margin: -2px 0px 0px 0px;
}
div.toc ul {
	padding-left: .75em;
}
div.toc li {
	font-size: 12px;
}
div.toc a {
	text-decoration: none;
	color:#9DAFA3;
}
div.toc a:hover {
	color: #FFFFCC;
	text-decoration: underline;
}
div.toc a:visited {
	color: #D3DED3;
}

code{
	font-family: "Courier New",Georgia,helvetica, sans-serif;
	padding: .1em;
	color:#835959;
	font-size: 110%;
	font-weight:bold ;
}

</STYLE>
</HEAD>
<BODY>

<DIV CLASS="header" ID="header">
<H1>﻿Techniques</H1>
<H2>ChaiShushan &lt;chaishushan@gmail.com&gt;[整理]</H2>
<H3>2012-05-25</H3>
</DIV>

<DIV CLASS="toc" ID="toc">
  <OL>
  <LI><A HREF="#toc1">Streaming Multiple Messages</A>
  <LI><A HREF="#toc2">Large Data Sets</A>
  <LI><A HREF="#toc3">Union Types</A>
  <LI><A HREF="#toc4">Self-describing Messages</A>
  </OL>

</DIV>
<DIV CLASS="body" ID="body">
<P>
This page describes some commonly-used design patterns for dealing with Protocol Buffers. You can also send design and usage questions to the Protocol Buffers discussion group.
</P>
<A NAME="toc1"></A>
<H1>1. Streaming Multiple Messages</H1>
<P>
If you want to write multiple messages to a single file or stream, it is up to you to keep track of where one message ends and the next begins. The Protocol Buffer wire format is not self-delimiting, so protocol buffer parsers cannot determine where a message ends on their own. The easiest way to solve this problem is to write the size of each message before you write the message itself. When you read the messages back in, you read the size, then read the bytes into a separate buffer, then parse from that buffer. (If you want to avoid copying bytes to a separate buffer, check out the CodedInputStream class (in both C++ and Java) which can be told to limit reads to a certain number of bytes.)
</P>
<A NAME="toc2"></A>
<H1>2. Large Data Sets</H1>
<P>
Protocol Buffers are not designed to handle large messages. As a general rule of thumb, if you are dealing in messages larger than a megabyte each, it may be time to consider an alternate strategy.
</P>
<P>
That said, Protocol Buffers are great for handling individual messages within a large data set. Usually, large data sets are really just a collection of small pieces, where each small piece may be a structured piece of data. Even though Protocol Buffers cannot handle the entire set at once, using Protocol Buffers to encode each piece greatly simplifies your problem: now all you need is to handle a set of byte strings rather than a set of structures.
</P>
<P>
Protocol Buffers do not include any built-in support for large data sets because different situations call for different solutions. Sometimes a simple list of records will do while other times you may want something more like a database. Each solution should be developed as a separate library, so that only those who need it need to pay the costs.
</P>
<A NAME="toc3"></A>
<H1>3. Union Types</H1>
<P>
You may sometimes want to send a message that could be one of several different types. However, protocol buffer parsers cannot necessarily determine the type of a message based on the contents alone. So how do you make sure that the recipient application knows how to decode your message? One solution is to create a wrapper message that has one optional field for each possible message type.
</P>
<P>
For example, if you have message types Foo, Bar, and Baz, you can combine them with a type like:
</P>
<PRE>
message OneMessage {
  // One of the following will be filled in.
  optional Foo foo = 1;
  optional Bar bar = 2;
  optional Baz baz = 3;
}
</PRE>
<P></P>
<P>
You may also want to have an enum field that identifies which message is filled in, so that you can switch on it:
</P>
<PRE>
message OneMessage {
  enum Type { FOO = 1; BAR = 2; BAZ = 3; }

  // Identifies which field is filled in.
  required Type type = 1;

  // One of the following will be filled in.
  optional Foo foo = 2;
  optional Bar bar = 3;
  optional Baz baz = 4;
}
</PRE>
<P></P>
<P>
If you have a very large number of possible types, listing every one of them in your container type may be unwieldy. Instead, you should consider using extensions:
</P>
<PRE>
message OneMessage {
  extensions 100 to max;
}

// Elsewhere...
extend OneMessage {
  optional Foo foo_ext = 100;
  optional Bar bar_ext = 101;
  optional Baz baz_ext = 102;
}
</PRE>
<P></P>
<P>
Note that you can use the ListFields reflection method (in C++, Java, and Python) to get a list of all fields present in the message, including extensions. You might use this as part of a scheme for registering handlers for diverse message types.
</P>
<A NAME="toc4"></A>
<H1>4. Self-describing Messages</H1>
<P>
Protocol Buffers do not contain descriptions of their own types. Thus, given only a raw message without the corresponding .proto file defining its type, it is difficult to extract any useful data.
</P>
<P>
However, note that the contents of a .proto file can itself be represented using protocol buffers. The file src/google/protobuf/descriptor.proto in the source code package defines the message types involved. protoc can output a FileDescriptorSet – which represents a set of .proto files – using the --descriptor_set_out option. With this, you could define a self-describing protocol message like so:
</P>
<PRE>
message SelfDescribingMessage {
  // Set of .proto files which define the type.
  required FileDescriptorSet proto_files = 1;

  // Name of the message type.  Must be defined by one of the files in
  // proto_files.
  required string type_name = 2;

  // The message data.
  required bytes message_data = 3;
}
</PRE>
<P></P>
<P>
By using classes like DynamicMessage (available in C++ and Java), you can then write tools which can manipulate SelfDescribingMessages.
</P>
</DIV>

<!-- html code generated by txt2tags 2.3 (http://txt2tags.sf.net) -->
<!-- cmdline: txt2tags cpp-generated.t2t cpptutorial.t2t encoding.t2t overview.t2t proto.t2t style.t2t techniques.t2t -->
</BODY></HTML>
