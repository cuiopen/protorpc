<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<META NAME="generator" CONTENT="http://txt2tags.sf.net">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>﻿Developer Guide</TITLE>
<STYLE TYPE="text/css">
/* t2t --css-sugar support css
version:
	v0.9 090430;fixed IE bad toc link color
	v0.8 070613;zoomq clean base gary,and support anchor ed Title
	v0.7 2004;zoomq creat base deviantart.com
*/
body {
	background-color : #fdfdfd;
	font-family: Tahoma,SimSun,arial, helvetica, sans-serif; 
	font-size: 92%;
	/* line-height: 120%; */
	margin: 0px;
	padding: 0px;
	color:#494D4A;
}
SUP,SUB{
	font-size:11px;
}
a {
	color: #3B4A4A;
	text-decoration:underline; 
}
a:hover {color: #930;
	text-decoration: none; 
}
a:visited {color: #45544A;
	}
img {border: none;}
/*"
"font-family: courier, monospace;
*/

pre{
	border-left: 2px solid #AEBDCC;
	
	/*background-color: #323232;
	color:#9AEF3F;*/
	color:#5A695F;
	
	padding: 1em;
	font-family: "Courier New",Georgia,helvetica, sans-serif;  
	white-space: pre;
	/*" begin css 3 or browser specific rules - do not remove!
	see: http://forums.techguy.org/archive/index.php/t-249849.html */
	white-space: pre-wrap;
	word-wrap: break-word;
	white-space: -moz-pre-wrap;
	white-space: -pre-wrap;
	white-space: -o-pre-wrap;
	/* end css 3 or browser specific rules */
}
UL,OL{
	margin: 0em 0 0 .5em;
	padding: 0 .25em 0em 1em;
}
/*定义声明组*/
DL,DT{
	margin: .25em 0 0 .25em;
	padding: 0em 0em 0em .25em;
}
DT{
	font-weight:bold;
	font-size:105%;
}
DD{
	margin: .25em 0 0 .5em;
	padding: 0 .25em .25em 1em;
}
ul.plain {
	list-style-type: none;
	margin-left: 5px;
	padding-left: 5px;
}
H1,H2,H3,H4,H5,H6{
	font-family: Verdana, arial, helvetica, sans-serif; 
	text-align: left;
	color:#5A695F;
	margin-left : .5em;  
	padding : 4px;
	line-height: 1.2em;
}
H1 { 
	background-color :transparent;
	border-left : 5px solid #404E4E ;
	border-bottom : 1px dashed  #A9B3A9 ;
	font-size: 1.5em;
}
h2 { 
	border-left : 10px solid #526157 ;
	border-bottom : 1px dashed  #A9B3A9 ;
	font-size: 1.4em;
}
h3 {
	border-left : 15px solid #738278 ;
	border-bottom : 1px dashed  #A9B3A9 ;
	font-size: 1.3em;
}

h4 {
	border-left : 20px solid #88938D ;
	border-bottom : 1px dashed  #A9B3A9 ;
	font-size: 1.2em;
}
h5{
	border-left : 25px solid #B2B8B2 ;
	border-bottom : 1px dashed  #A9B3A9 ;
	font-size: 1.1em;
}
h6{
	border-left : 30px solid #C4C8C4 ;
	border-bottom : 1px dashed  #A9B3A9 ;
	font-size: 1em;
}

H1 A{text-decoration:none;}
H1 A:hover{text-decoration:overline;}

H2 A{text-decoration:none;}
H2 A:hover{text-decoration:overline;}

H3 A{text-decoration:none;}
H3 A:hover{text-decoration:overline;}

H4 A{text-decoration:none;}
H4 A:hover{text-decoration:overline;}

H5 A{text-decoration:none;}
H5 A:hover{text-decoration:overline;}

/*padding:5px 15px 10px 15px;  */
#banner {
	font-family: "Courier New",Georgia,Verdana, arial, helvetica, sans-serif;
	color:#CED8CE;
	background:#25342A;
	padding-left: 10px;
	letter-spacing: .2em;
	font-size:24px;
	font-weight:bold ;
	border-top:4px solid #738278;
	border-bottom: 0px solid  #4A584A;
}
#banner A{
	color:#E0FFB8;
	text-decoration:none;
}
#banner A:hover{
	color:#DAF4DA;
	text-decoration:overline ;
}
#banner SUP,SUB{
	font-size:12px;
	color:#DAE4DA;
}
#banner P#main{
	margin: 4px;
	padding: 4px;
}
#banner P#sub{
	font-size:12px;letter-spacing: 5px;
	margin: 4px;
	padding: 4px 4px 10px 4px;
}
#banner DIV#recent {
	border : 0px dotted #930;
	color:#DAE4DA;
	font-family: Georgia,arial, helvetica,sans-serif;
	position : absolute ;
	top: 2em;
	left: 39%;
	font-size:16px;
	letter-spacing: 2px;
}
/*text-transform:uppercase;*/
#content { 
	width: 69%;
	position: absolute;	
	background-color: transparence;
	border-right: 0px dotted #4A584A;
	margin: 0px;
	padding: 10px 5px 10px 10px;
}
/*<h2>Mon, 23 Jan 2006</h2>*/
h2.blosxomDate{
	font-family: Georgia,Verdana, arial, helvetica, sans-serif;
	text-align: right;
	border:0px solid #2B3A3A;
	margin: 0px 5px 5px 0px;
	padding: 0px 15px 0px 0px;
	border-bottom: 1px solid #2B3A3A;
}
H3#blosxomTitle {
	font-size: 90%;
	border-left:4px solid #88938D;
	border-bottom : 0px dashed  #A9B3A9 ;
	background-color: #546359;
	color:#A7AFA7;
	padding: 4px;
	margin: 5px 0px 0px 0px;
	font-weight:normal;
}

H3#blosxomTitle a { 
	color: #DDDDD0;
}

.blosxomStory{
	padding: 4px; 
	font-size: 92%;   
	border-left:2px solid #88938D;
	background-color: #ECEEEC;
}

.blosxomStory a { 
	color:#835959;
}

/*
"font-family: "Courier New",Georgia,helvetica, sans-serif; 
*/
.blosxomStoryLinks{
	font-size:90%;
	padding: 2px;
	margin: 0px;
	border:0px dotted #2B3A3A;
	background-color: #546359;
	color:#A7AFA7;
}
.blosxomStoryLinks a {
	color: #DDDDD0;
	text-decoration:none; 
}
.blosxomStoryLinks a:hover {
	color: #DDDDD0;
	text-decoration: underline; 
}
.blosxomStoryLinks a:visited {
	color: #BAC4BB;
}
/*"margin: 1px 0px 2px 0px  */
div.body {
	margin: 0px 10px 0px 10px;
}
div#header {
	font-family: Verdana, Arial, Helvetica, Sans-Serif;
	border-bottom: 0px dotted black;
	margin: 0px;
	padding: 0px;
	background-color :#454545;
}
/*文章大标*/
div#header H1{
	float: left;
	margin: 5px 5px 10px 15px;
	padding: 5px;
	font-size: 200%;
	font-weight : normal;
	color:#DAE4DA;
	border:0px;
}
/*文章副标*/
div#header H2 {
	text-align: right;
	margin: 0em;
	padding: .5em .5em 0em 0em;
	font-size: 130%;
	font-weight : normal;
	border:0px;
	color:#DAE4DA;
	border-right : 4px solid #A7AFA7;
}
/*文章说明*/
div#header H3{
	text-align: right;
	margin: 0em;
	padding: 0em .5em 0em 0em;
	font-size: 13px;
	font-weight : normal;
	border:0px;
	color:#D2D8D2;
	border-bottom : 2px solid #A7AFA7;
	border-right :  4px solid #A7AFA7;
}

div.toc {
	float: right;
	background-color :#454545;
	color:#BAC4BA;
	border-bottom : 4px solid #A7AFA7;
	border-left :   2px solid #A7AFA7;
	border-right :   4px solid #A7AFA7;
	padding: .5em 0em .5em .5em;
	margin: -2px 0px 0px 0px;
}
div.toc ul {
	padding-left: .75em;
}
div.toc li {
	font-size: 12px;
}
div.toc a {
	text-decoration: none;
	color:#9DAFA3;
}
div.toc a:hover {
	color: #FFFFCC;
	text-decoration: underline;
}
div.toc a:visited {
	color: #D3DED3;
}

code{
	font-family: "Courier New",Georgia,helvetica, sans-serif;
	padding: .1em;
	color:#835959;
	font-size: 110%;
	font-weight:bold ;
}

</STYLE>
</HEAD>
<BODY>

<DIV CLASS="header" ID="header">
<H1>﻿Developer Guide</H1>
<H2>ChaiShushan &lt;chaishushan@gmail.com&gt;[整理]</H2>
<H3>2012-05-25</H3>
</DIV>

<DIV CLASS="toc" ID="toc">
  <OL>
  <LI><A HREF="#toc1">What are protocol buffers?</A>
  <LI><A HREF="#toc2">How do they work?</A>
  <LI><A HREF="#toc3">Why not just use XML?</A>
  <LI><A HREF="#toc4">Sounds like the solution for me! How do I get started?</A>
  <LI><A HREF="#toc5">A bit of history</A>
  </OL>

</DIV>
<DIV CLASS="body" ID="body">
<P>
Welcome to the developer documentation for protocol buffers – a language-neutral, platform-neutral, extensible way of serializing structured data for use in communications protocols, data storage, and more.
</P>
<P>
This documentation is aimed at Java, C++, or Python developers who want to use protocol buffers in their applications. This overview introduces protocol buffers and tells you what you need to do to get started – you can then go on to follow the tutorials or delve deeper into protocol buffer encoding. API reference documentation is also provided for all three languages, as well as language and style guides for writing .proto files.
</P>
<A NAME="toc1"></A>
<H1>1. What are protocol buffers?</H1>
<P>
Protocol buffers are a flexible, efficient, automated mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages. You can even update your data structure without breaking deployed programs that are compiled against the "old" format.
</P>
<A NAME="toc2"></A>
<H1>2. How do they work?</H1>
<P>
You specify how you want the information you're serializing to be structured by defining protocol buffer message types in .proto files. Each protocol buffer message is a small logical record of information, containing a series of name-value pairs. Here's a very basic example of a .proto file that defines a message containing information about a person:
</P>
<PRE>
message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}
</PRE>
<P></P>
<P>
As you can see, the message format is simple – each message type has one or more uniquely numbered fields, and each field has a name and a value type, where value types can be numbers (integer or floating-point), booleans, strings, raw bytes, or even (as in the example above) other protocol buffer message types, allowing you to structure your data hierarchically. You can specify optional fields, required fields, and repeated fields. You can find more information about writing .proto files in the Protocol Buffer Language Guide.
</P>
<P>
Once you've defined your messages, you run the protocol buffer compiler for your application's language on your .proto file to generate data access classes. These provide simple accessors for each field (like query() and set_query()) as well as methods to serialize/parse the whole structure to/from raw bytes – so, for instance, if your chosen language is C++, running the compiler on the above example will generate a class called Person. You can then use this class in your application to populate, serialize, and retrieve Person protocol buffer messages. You might then write some code like this:
</P>
<PRE>
Person person;
person.set_name("John Doe");
person.set_id(1234);
person.set_email("jdoe@example.com");
fstream output("myfile", ios::out | ios::binary);
person.SerializeToOstream(&amp;output);
</PRE>
<P></P>
<P>
Then, later on, you could read your message back in:
</P>
<PRE>
fstream input("myfile", ios::in | ios::binary);
Person person;
person.ParseFromIstream(&amp;input);
cout &lt;&lt; "Name: " &lt;&lt; person.name() &lt;&lt; endl;
cout &lt;&lt; "E-mail: " &lt;&lt; person.email() &lt;&lt; endl;
</PRE>
<P></P>
<P>
You can add new fields to your message formats without breaking backwards-compatibility; old binaries simply ignore the new field when parsing. So if you have a communications protocol that uses protocol buffers as its data format, you can extend your protocol without having to worry about breaking existing code.
</P>
<P>
You'll find a complete reference for using generated protocol buffer code in the API Reference section, and you can find out more about how protocol buffer messages are encoded in Protocol Buffer Encoding.
</P>
<A NAME="toc3"></A>
<H1>3. Why not just use XML?</H1>
<P>
Protocol buffers have many advantages over XML for serializing structured data. Protocol buffers:
</P>
<UL>
<LI>are simpler
<LI>are 3 to 10 times smaller
<LI>are 20 to 100 times faster
<LI>are less ambiguous
<LI>generate data access classes that are easier to use programmatically
</UL>

<P>
For example, let's say you want to model a person with a name and an email. In XML, you need to do:
</P>
<PRE>
  &lt;person&gt;
    &lt;name&gt;John Doe&lt;/name&gt;
    &lt;email&gt;jdoe@example.com&lt;/email&gt;
  &lt;/person&gt;
</PRE>
<P></P>
<P>
while the corresponding protocol buffer message (in protocol buffer text format) is:
</P>
<PRE>
# Textual representation of a protocol buffer.
# This is *not* the binary format used on the wire.
person {
  name: "John Doe"
  email: "jdoe@example.com"
}
</PRE>
<P></P>
<P>
When this message is encoded to the protocol buffer binary format (the text format above is just a convenient human-readable representation for debugging and editing), it would probably be 28 bytes long and take around 100-200 nanoseconds to parse. The XML version is at least 69 bytes if you remove whitespace, and would take around 5,000-10,000 nanoseconds to parse.
</P>
<P>
Also, manipulating a protocol buffer is much easier:
</P>
<PRE>
  cout &lt;&lt; "Name: " &lt;&lt; person.name() &lt;&lt; endl;
  cout &lt;&lt; "E-mail: " &lt;&lt; person.email() &lt;&lt; endl;
</PRE>
<P></P>
<P>
Whereas with XML you would have to do something like:
</P>
<PRE>
  cout &lt;&lt; "Name: "
       &lt;&lt; person.getElementsByTagName("name")-&gt;item(0)-&gt;innerText()
       &lt;&lt; endl;
  cout &lt;&lt; "E-mail: "
       &lt;&lt; person.getElementsByTagName("email")-&gt;item(0)-&gt;innerText()
       &lt;&lt; endl;
</PRE>
<P></P>
<P>
However, protocol buffers are not always a better solution than XML – for instance, protocol buffers would not be a good way to model a text-based document with markup (e.g. HTML), since you cannot easily interleave structure with text. In addition, XML is human-readable and human-editable; protocol buffers, at least in their native format, are not. XML is also – to some extent – self-describing. A protocol buffer is only meaningful if you have the message definition (the .proto file).
</P>
<A NAME="toc4"></A>
<H1>4. Sounds like the solution for me! How do I get started?</H1>
<P>
Download the package – this contains the complete source code for the Java, Python, and C++ protocol buffer compilers, as well as the classes you need for I/O and testing. To build and install your compiler, follow the instructions in the README.
</P>
<P>
Once you're all set, try following the tutorial for your chosen language – this will step you through creating a simple application that uses protocol buffers.
</P>
<A NAME="toc5"></A>
<H1>5. A bit of history</H1>
<P>
Protocol buffers were initially developed at Google to deal with an index server request/response protocol. Prior to protocol buffers, there was a format for requests and responses that used hand marshalling/unmarshalling of requests and responses, and that supported a number of versions of the protocol. This resulted in some very ugly code, like:
</P>
<PRE>
 if (version == 3) {
   ...
 } else if (version &gt; 4) {
   if (version == 5) {
     ...
   }
   ...
 }
</PRE>
<P></P>
<P>
Explicitly formatted protocols also complicated the rollout of new protocol versions, because developers had to make sure that all servers between the originator of the request and the actual server handling the request understood the new protocol before they could flip a switch to start using the new protocol.
</P>
<P>
Protocol buffers were designed to solve many of these problems:
</P>
<UL>
<LI>New fields could be easily introduced, and intermediate servers that didn't need to inspect the data could simply parse it and pass through the data without needing to know about all the fields.
<LI>Formats were more self-describing, and could be dealt with from a variety of languages (C++, Java, etc.)
</UL>

<P>
However, users still needed to hand-write their own parsing code.
</P>
<P>
As the system evolved, it acquired a number of other features and uses:
</P>
<UL>
<LI>Automatically-generated serialization and deserialization code avoided the need for hand parsing.
<LI>In addition to being used for short-lived RPC (Remote Procedure Call) requests, people started to use protocol buffers as a handy self-describing format for storing data persistently (for example, in Bigtable).
<LI>Server RPC interfaces started to be declared as part of protocol files, with the protocol compiler generating stub classes that users could override with actual implementations of the server's interface.
</UL>

<P>
Protocol buffers are now Google's lingua franca for data – at time of writing, there are 48,162 different message types defined in the Google code tree across 12,183 .proto files. They're used both in RPC systems and for persistent storage of data in a variety of storage systems.
</P>
</DIV>

<!-- html code generated by txt2tags 2.3 (http://txt2tags.sf.net) -->
<!-- cmdline: txt2tags cpp-generated.t2t cpptutorial.t2t encoding.t2t overview.t2t proto.t2t style.t2t techniques.t2t -->
</BODY></HTML>
