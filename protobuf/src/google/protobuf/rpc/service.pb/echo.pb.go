// Code generated by protoc-gen-go.
// source: echo.proto
// DO NOT EDIT!

package service

import proto "encoding/protobuf/proto"
import json "encoding/json"
import math "math"

import "io"
import "net"
import "net/rpc"
import "net/rpc/protorpc"

// Reference proto, json, and math imports to suppress error if they are not otherwise used.
var _ = proto.Marshal
var _ = &json.SyntaxError{}
var _ = math.Inf

type EchoRequest struct {
	Msg              *string `protobuf:"bytes,1,opt,name=msg" json:"msg,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EchoRequest) Reset()         { *m = EchoRequest{} }
func (m *EchoRequest) String() string { return proto.CompactTextString(m) }
func (*EchoRequest) ProtoMessage()    {}

func (m *EchoRequest) GetMsg() string {
	if m != nil && m.Msg != nil {
		return *m.Msg
	}
	return ""
}

type EchoResponse struct {
	Msg              *string `protobuf:"bytes,1,opt,name=msg" json:"msg,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EchoResponse) Reset()         { *m = EchoResponse{} }
func (m *EchoResponse) String() string { return proto.CompactTextString(m) }
func (*EchoResponse) ProtoMessage()    {}

func (m *EchoResponse) GetMsg() string {
	if m != nil && m.Msg != nil {
		return *m.Msg
	}
	return ""
}

func init() {
}

type EchoService interface {
	Echo(in *EchoRequest, out *EchoResponse) error
}

// RegisterEchoService publish the given EchoService implementation on the server.
func RegisterEchoService(srv *rpc.Server, x EchoService) error {
	if err := srv.RegisterName("EchoService", x); err != nil {
		return err
	}
	return nil
}

// ServeEchoService serves the given EchoService implementation on conn.
func ServeEchoService(conn io.ReadWriteCloser, x EchoService) error {
	srv := rpc.NewServer()
	if err := srv.RegisterName("EchoService", x); err != nil {
		return err
	}
	srv.ServeCodec(protorpc.NewServerCodec(conn))
	return nil
}

// ListenAndServeEchoService listen announces on the local network address laddr
// and serves the given EchoService implementation.
func ListenAndServeEchoService(network, addr string, x EchoService) error {
	clients, err := net.Listen(network, addr)
	if err != nil {
		return err
	}
	srv := rpc.NewServer()
	if err := srv.RegisterName("EchoService", x); err != nil {
		return err
	}
	for {
		conn, err := clients.Accept()
		if err != nil {
			return err
		}
		go srv.ServeCodec(protorpc.NewServerCodec(conn))
	}
	panic("unreachable")
}

type rpcEchoServiceStub struct {
	*rpc.Client
}

func (c *rpcEchoServiceStub) Echo(in *EchoRequest, out *EchoResponse) error {
	return c.Call("EchoService.Echo", in, out)
}

// DialEchoService connects to an EchoService at the specified network address.
func DialEchoService(network, addr string) (*rpc.Client, EchoService, error) {
	conn, err := net.Dial(network, addr)
	if err != nil {
		return nil, nil, err
	}
	c, srv := NewEchoServiceClient(conn)
	return c, srv, nil
}

// NewEchoServiceClient returns a EchoService rpc.Client and stub to handle
// requests to the set of EchoService at the other end of the connection.
func NewEchoServiceClient(conn io.ReadWriteCloser) (*rpc.Client, EchoService) {
	c := rpc.NewClientWithCodec(protorpc.NewClientCodec(conn))
	return c, &rpcEchoServiceStub{c}
}

// NewEchoServiceStub returns a EchoService stub to handle rpc.Client.
func NewEchoServiceStub(c *rpc.Client) EchoService {
	return &rpcEchoServiceStub{c}
}

type EchoServiceA interface {
	Echo(in *EchoRequest, out *EchoResponse) error
}

// RegisterEchoServiceA publish the given EchoServiceA implementation on the server.
func RegisterEchoServiceA(srv *rpc.Server, x EchoServiceA) error {
	if err := srv.RegisterName("EchoServiceA", x); err != nil {
		return err
	}
	return nil
}

// ServeEchoServiceA serves the given EchoServiceA implementation on conn.
func ServeEchoServiceA(conn io.ReadWriteCloser, x EchoServiceA) error {
	srv := rpc.NewServer()
	if err := srv.RegisterName("EchoServiceA", x); err != nil {
		return err
	}
	srv.ServeCodec(protorpc.NewServerCodec(conn))
	return nil
}

// ListenAndServeEchoServiceA listen announces on the local network address laddr
// and serves the given EchoServiceA implementation.
func ListenAndServeEchoServiceA(network, addr string, x EchoServiceA) error {
	clients, err := net.Listen(network, addr)
	if err != nil {
		return err
	}
	srv := rpc.NewServer()
	if err := srv.RegisterName("EchoServiceA", x); err != nil {
		return err
	}
	for {
		conn, err := clients.Accept()
		if err != nil {
			return err
		}
		go srv.ServeCodec(protorpc.NewServerCodec(conn))
	}
	panic("unreachable")
}

type rpcEchoServiceAStub struct {
	*rpc.Client
}

func (c *rpcEchoServiceAStub) Echo(in *EchoRequest, out *EchoResponse) error {
	return c.Call("EchoServiceA.Echo", in, out)
}

// DialEchoServiceA connects to an EchoServiceA at the specified network address.
func DialEchoServiceA(network, addr string) (*rpc.Client, EchoServiceA, error) {
	conn, err := net.Dial(network, addr)
	if err != nil {
		return nil, nil, err
	}
	c, srv := NewEchoServiceAClient(conn)
	return c, srv, nil
}

// NewEchoServiceAClient returns a EchoServiceA rpc.Client and stub to handle
// requests to the set of EchoServiceA at the other end of the connection.
func NewEchoServiceAClient(conn io.ReadWriteCloser) (*rpc.Client, EchoServiceA) {
	c := rpc.NewClientWithCodec(protorpc.NewClientCodec(conn))
	return c, &rpcEchoServiceAStub{c}
}

// NewEchoServiceAStub returns a EchoServiceA stub to handle rpc.Client.
func NewEchoServiceAStub(c *rpc.Client) EchoServiceA {
	return &rpcEchoServiceAStub{c}
}

type EchoServiceB interface {
	Echo(in *EchoRequest, out *EchoResponse) error
}

// RegisterEchoServiceB publish the given EchoServiceB implementation on the server.
func RegisterEchoServiceB(srv *rpc.Server, x EchoServiceB) error {
	if err := srv.RegisterName("EchoServiceB", x); err != nil {
		return err
	}
	return nil
}

// ServeEchoServiceB serves the given EchoServiceB implementation on conn.
func ServeEchoServiceB(conn io.ReadWriteCloser, x EchoServiceB) error {
	srv := rpc.NewServer()
	if err := srv.RegisterName("EchoServiceB", x); err != nil {
		return err
	}
	srv.ServeCodec(protorpc.NewServerCodec(conn))
	return nil
}

// ListenAndServeEchoServiceB listen announces on the local network address laddr
// and serves the given EchoServiceB implementation.
func ListenAndServeEchoServiceB(network, addr string, x EchoServiceB) error {
	clients, err := net.Listen(network, addr)
	if err != nil {
		return err
	}
	srv := rpc.NewServer()
	if err := srv.RegisterName("EchoServiceB", x); err != nil {
		return err
	}
	for {
		conn, err := clients.Accept()
		if err != nil {
			return err
		}
		go srv.ServeCodec(protorpc.NewServerCodec(conn))
	}
	panic("unreachable")
}

type rpcEchoServiceBStub struct {
	*rpc.Client
}

func (c *rpcEchoServiceBStub) Echo(in *EchoRequest, out *EchoResponse) error {
	return c.Call("EchoServiceB.Echo", in, out)
}

// DialEchoServiceB connects to an EchoServiceB at the specified network address.
func DialEchoServiceB(network, addr string) (*rpc.Client, EchoServiceB, error) {
	conn, err := net.Dial(network, addr)
	if err != nil {
		return nil, nil, err
	}
	c, srv := NewEchoServiceBClient(conn)
	return c, srv, nil
}

// NewEchoServiceBClient returns a EchoServiceB rpc.Client and stub to handle
// requests to the set of EchoServiceB at the other end of the connection.
func NewEchoServiceBClient(conn io.ReadWriteCloser) (*rpc.Client, EchoServiceB) {
	c := rpc.NewClientWithCodec(protorpc.NewClientCodec(conn))
	return c, &rpcEchoServiceBStub{c}
}

// NewEchoServiceBStub returns a EchoServiceB stub to handle rpc.Client.
func NewEchoServiceBStub(c *rpc.Client) EchoServiceB {
	return &rpcEchoServiceBStub{c}
}
