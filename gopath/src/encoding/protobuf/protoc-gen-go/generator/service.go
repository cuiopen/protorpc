// Copyright 2013 <chaishushan{AT}gmail.com>. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package generator

import (
	descriptor "encoding/protobuf/protoc-gen-go/descriptor"
)

// servicePlugin produce the Service interface.
type servicePlugin struct {
	*Generator
}

// Name returns the name of the plugin.
func (p *servicePlugin) Name() string { return "ServiceInterface" }

// Init is called once after data structures are built but before
// code generation begins.
func (p *servicePlugin) Init(g *Generator) {
	p.Generator = g
}

// Generate produces the code generated by the plugin for this file.
func (p *servicePlugin) GenerateImports(file *FileDescriptor) {
	if !p.getGenericServicesOptions(file) {
		return
	}
	if len(file.Service) > 0 {
		p.P(`import "goto_rpc"`)
	}
}

// Generate generates the Service interface.
func (p *servicePlugin) Generate(file *FileDescriptor) {
	if !p.getGenericServicesOptions(file) {
		return
	}
	for _, svc := range file.Service {
		var _ = svc
		p.genAsynServiceInterface(svc)
		p.genSyncServiceInterface(svc)
		p.genServiceServerAsyn(svc)
		p.genServiceServerSync(svc)
		p.genServiceClient(svc)
	}
}

func (p *servicePlugin) getGenericServicesOptions(file *FileDescriptor) bool {
	if file.Options.GetCcGenericServices() {
		return true
	}
	if file.Options.GetJavaGenericServices() {
		return true
	}
	if file.Options.GetPyGenericServices() {
		return true
	}
	return false
}

func (p *servicePlugin) genAsynServiceInterface(svc *descriptor.ServiceDescriptorProto) {
	name := CamelCase(*svc.Name)

	// type {Service} interface
	p.P("type I", name, "Asyn interface {")
	p.In()
	for _, m := range svc.Method {
		method := CamelCase(*m.Name)
		iType := p.ObjectNamed(*m.InputType)
		//oType := p.ObjectNamed(*m.OutputType)
		p.P(method, "(ctx goto_rpc.IContext, request *", p.TypeName(iType), ")")
	}
	p.Out()
	p.P("}")
}

func (p *servicePlugin) genSyncServiceInterface(svc *descriptor.ServiceDescriptorProto) {
	name := CamelCase(*svc.Name)

	// type {Service} interface
	p.P("type I", name, "Sync interface {")
	p.In()
	for _, m := range svc.Method {
		method := CamelCase(*m.Name)
		iType := p.ObjectNamed(*m.InputType)
		oType := p.ObjectNamed(*m.OutputType)
		p.P(method, "(ctx goto_rpc.IContext, request *", p.TypeName(iType),
			") (response *", p.TypeName(oType), ", status byte)")
	}
	p.Out()
	p.P("}")
}

func (p *servicePlugin) genServiceServerAsyn(svc *descriptor.ServiceDescriptorProto) {
	name := CamelCase(*svc.Name)

	p.P("func Register", name, "Asyn(srv *goto_rpc.Server, service I", name, "Asyn) (e error) {")
	p.In()

	for _, m := range svc.Method {
		method := CamelCase(*m.Name)
		iType := p.ObjectNamed(*m.InputType)
		oType := p.ObjectNamed(*m.OutputType)

		p.P(`e = srv.AddServiceFunc("`, name, ".", method, `", func(ctx goto_rpc.IContext, request proto.Message) {`)

		p.In()
		p.P("service.", method, "(ctx, request.(*", p.TypeName(iType), "))")
		p.Out()

		p.P("}, func() proto.Message {")

		p.In()
		p.P("return &", p.TypeName(iType), "{}")
		p.Out()

		p.P("}, func() proto.Message {")

		p.In()
		p.P("return &", p.TypeName(oType), "{}")
		p.Out()

		p.P("})")
		p.P("if e != nil { return e }")
		p.P("")
	}
	p.P("return nil")

	p.Out()
	p.P("}")
}

func (p *servicePlugin) genServiceServerSync(svc *descriptor.ServiceDescriptorProto) {
	name := CamelCase(*svc.Name)

	p.P("func Register", name, "Sync(srv *goto_rpc.Server, service I", name, "Sync) (e error) {")
	p.In()

	for _, m := range svc.Method {
		method := CamelCase(*m.Name)
		iType := p.ObjectNamed(*m.InputType)
		oType := p.ObjectNamed(*m.OutputType)
		p.P("e = srv.AddServiceFunc(\"", name, ".", method, "\", func(ctx goto_rpc.IContext, request proto.Message) {")

		p.In()
		p.P("rsp, s := service.", method, "(ctx, request.(*", p.TypeName(iType), "))")
		p.P("ctx.Reply(s, rsp)")
		p.Out()

		p.P("}, func() proto.Message {")

		p.In()
		p.P("return &", p.TypeName(iType), "{}")
		p.Out()

		p.P("}, func() proto.Message {")

		p.In()
		p.P("return &", p.TypeName(oType), "{}")
		p.Out()

		p.P("})")
		p.P("if e != nil { return e }")
		p.P("")
	}

	p.P("return nil")
	p.Out()
	p.P("}")
}

func (p *servicePlugin) genServiceClient(svc *descriptor.ServiceDescriptorProto) {
	name := CamelCase(*svc.Name)

	// stub struct
	stub_name := name + "_Stub"
	p.P("type ", stub_name, " struct {")
	p.In()
	p.P("*goto_rpc.Client")
	p.Out()
	p.P("}")

	// New stub
	p.P("func New", stub_name, "(c *goto_rpc.Client) (stub *", stub_name, ", e error) {")
	p.In()
	for _, m := range svc.Method {
		method := CamelCase(*m.Name)
		iType := p.ObjectNamed(*m.InputType)
		oType := p.ObjectNamed(*m.OutputType)
		p.P("e = c.AddServiceInfo(\"", name, ".", method, "\", func() proto.Message {")
		p.In()
		p.P("return &", p.TypeName(iType), "{}")
		p.Out()
		p.P("}, func() proto.Message {")
		p.In()
		p.P("return &", p.TypeName(oType), "{}")
		p.Out()
		p.P("})")
		p.P("if e != nil { return }")
		p.P("")
	}
	p.P("stub = &ArithService_Stub{c}")
	p.P("return")
	p.Out()
	p.P("}")

	// sync methods.
	for _, m := range svc.Method {
		method := CamelCase(*m.Name)
		iType := p.ObjectNamed(*m.InputType)
		oType := p.ObjectNamed(*m.OutputType)

		p.P("func (stub *", stub_name, ") ", method, "(request *", p.TypeName(iType), ") (*", p.TypeName(oType), ", error) {")
		p.In()
		p.P("rsp, e := stub.Call(\"", name, ".", method, "\", request)")
		p.P("response, _ := rsp.(*", p.TypeName(oType), ")")
		p.P("return response, e")
		p.Out()
		p.P("}")
	}

	// asyn methods.
	for _, m := range svc.Method {
		method := CamelCase(*m.Name)
		iType := p.ObjectNamed(*m.InputType)
		oType := p.ObjectNamed(*m.OutputType)

		p.P("func (stub *", stub_name, ") Asyn", method, "(request *", p.TypeName(iType), ", cb func(error, *", p.TypeName(oType), ")) error {")
		p.In()
		p.P("return stub.AsynCall(\"", name, ".", method, "\", request, func(err error, rsp proto.Message) {")
		p.In()
		p.P("response, _ := rsp.(*", p.TypeName(oType), ")")
		p.P("cb(err, response)")
		p.Out()
		p.P("})")
		p.Out()
		p.P("}")
	}

}

func init() {
	RegisterPlugin(new(servicePlugin))
}

